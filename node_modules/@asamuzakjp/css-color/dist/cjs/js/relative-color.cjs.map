{"version":3,"file":"relative-color.cjs","sources":["../../../src/js/relative-color.ts"],"sourcesContent":["/**\n * relative-color.js\n */\n\nimport { SyntaxFlag, color as colorParser } from '@csstools/css-color-parser';\nimport { parseComponentValue } from '@csstools/css-parser-algorithms';\nimport { TokenType, tokenize } from '@csstools/css-tokenizer';\nimport { LRUCache } from 'lru-cache';\nimport { isString } from './common';\nimport { colorToRgb } from './convert';\nimport { resolveDimension, serializeCalc } from './css-calc';\nimport { resolve } from './resolve';\nimport { roundToPrecision, valueToJsonString } from './util';\n\n/* types */\nimport type { ComponentValue } from '@csstools/css-parser-algorithms';\nimport type { CSSToken } from '@csstools/css-tokenizer';\n\n/* constants */\nimport {\n  CS_LAB,\n  CS_LCH,\n  FN_REL,\n  FN_REL_CAPT,\n  FN_VAR,\n  NONE,\n  SYN_COLOR_TYPE,\n  SYN_FN_MATH,\n  SYN_FN_VAR,\n  SYN_MIX,\n  VAL_SPEC\n} from './constant';\nimport { NAMED_COLORS } from './color';\nconst {\n  CloseParen: PAREN_CLOSE,\n  Comment: COMMENT,\n  Dimension: DIM,\n  EOF,\n  Function: FUNC,\n  Ident: IDENT,\n  Number: NUM,\n  OpenParen: PAREN_OPEN,\n  Percentage: PCT,\n  Whitespace: W_SPACE\n} = TokenType;\nconst {\n  HasNoneKeywords: NONE_KEY\n} = SyntaxFlag;\nconst OCT = 8;\nconst DEC = 10;\nconst HEX = 16;\nconst MAX_PCT = 100;\nconst MAX_RGB = 255;\n\n/* regexp */\nconst REG_COLOR_CAPT = new RegExp(\n  `^${FN_REL}(${SYN_COLOR_TYPE}|${SYN_MIX})\\\\s+`\n);\nconst REG_CS_HSL = /(?:hsla?|hwb)$/;\nconst REG_CS_CIE = new RegExp(`^(?:${CS_LAB}|${CS_LCH})$`);\nconst REG_FN_VAR = new RegExp(SYN_FN_VAR);\nconst REG_REL = new RegExp(FN_REL);\nconst REG_REL_CAPT = new RegExp(`^${FN_REL_CAPT}`);\nconst REG_START_MATH = new RegExp(SYN_FN_MATH);\nconst REG_START_REL = new RegExp(`^${FN_REL}`);\n\n/* cached results */\nexport const cachedResults = new LRUCache({\n  max: 4096\n});\n\n/**\n * resolve relative color channels\n * @param {Array.<Array>} tokens - tokens\n * @param {object} [opt] - options\n * @param {string} [opt.colorSpace] - color space\n * @returns {?Array.<string>} - resolved channels\n */\nexport function resolveColorChannels(\n  tokens: Array<CSSToken>,\n  opt: {\n    colorSpace?: string;\n    currentColor?: string;\n    dimension?: object;\n    format?: string;\n  } = {}\n): Array<string> | null {\n  if (!Array.isArray(tokens)) {\n    throw new TypeError(`${tokens} is not an array.`);\n  }\n  const { colorSpace, format } = opt;\n  const colorChannels = new Map([\n    ['color', ['r', 'g', 'b', 'alpha']],\n    ['hsl', ['h', 's', 'l', 'alpha']],\n    ['hsla', ['h', 's', 'l', 'alpha']],\n    ['hwb', ['h', 'w', 'b', 'alpha']],\n    ['lab', ['l', 'a', 'b', 'alpha']],\n    ['lch', ['l', 'c', 'h', 'alpha']],\n    ['oklab', ['l', 'a', 'b', 'alpha']],\n    ['oklch', ['l', 'c', 'h', 'alpha']],\n    ['rgb', ['r', 'g', 'b', 'alpha']],\n    ['rgba', ['r', 'g', 'b', 'alpha']]\n  ]);\n  const colorChannel = colorChannels.get(colorSpace as string);\n  const mathFunc = new Set();\n  const channels = [[], [], [], []] as Array<Array<string | number>>;\n  let i = 0;\n  let nest = 0;\n  let func = false;\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (!Array.isArray(token)) {\n      throw new TypeError(`${token} is not an array.`);\n    }\n    const [type, value, , , detail = {}] = token;\n    const numValue = (detail as {\n      value?: number;\n    })?.value as number | undefined;\n    const channel = channels[i]!;\n    switch (type as string) {\n      case DIM: {\n        let resolvedValue = resolveDimension(token, opt) as string | null;\n        if (!resolvedValue) {\n          resolvedValue = value as string;\n        }\n        channel.push(resolvedValue as string);\n        break;\n      }\n      case FUNC: {\n        channel.push(value);\n        func = true;\n        nest++;\n        if (REG_START_MATH.test(value)) {\n          mathFunc.add(nest);\n        }\n        break;\n      }\n      case IDENT: {\n        // invalid channel key\n        if (!colorChannel || !colorChannel.includes(value)) {\n          return null;\n        }\n        channel.push(value);\n        if (!func) {\n          i++;\n        }\n        break;\n      }\n      case NUM: {\n        const n = numValue ?? parseFloat(value);\n        channel.push(n);\n        if (!func) {\n          i++;\n        }\n        break;\n      }\n      case PAREN_OPEN: {\n        channel.push(value);\n        nest++;\n        break;\n      }\n      case PAREN_CLOSE: {\n        if (func) {\n          const lastValue = channel[channel.length - 1] as string | number;\n          if (lastValue === ' ') {\n            channel.splice(-1, 1, value);\n          } else {\n            channel.push(value);\n          }\n          if (mathFunc.has(nest)) {\n            mathFunc.delete(nest);\n          }\n          nest--;\n          if (nest === 0) {\n            func = false;\n            i++;\n          }\n        }\n        break;\n      }\n      case PCT: {\n        const n = numValue ?? parseFloat(value);\n        channel.push(n / MAX_PCT);\n        if (!func) {\n          i++;\n        }\n        break;\n      }\n      case W_SPACE: {\n        if (channel.length && func) {\n          const lastValue = channel[channel.length - 1] as string | number;\n          if (typeof lastValue === 'number') {\n            channel.push(value);\n          } else if (\n            isString(lastValue) &&\n            !lastValue.endsWith('(') &&\n            lastValue !== ' '\n          ) {\n            channel.push(value);\n          }\n        }\n        break;\n      }\n      default: {\n        if (type !== COMMENT && type !== EOF && func) {\n          channel.push(value);\n        }\n      }\n    }\n  }\n  const channelValues = [];\n  for (const channel of channels) {\n    if (channel.length === 1) {\n      const [resolvedValue] = channel;\n      channelValues.push(resolvedValue as string);\n    } else if (channel.length) {\n      const resolvedValue = serializeCalc(channel.join(''), {\n        format\n      });\n      if (resolvedValue) {\n        channelValues.push(resolvedValue);\n      } else {\n        return null;\n      }\n    }\n  }\n  return channelValues;\n}\n\n/**\n * extract origin color\n * @param {string} value - color value\n * @param {object} [opt] - options\n * @param {string} [opt.currentColor] - current color value\n * @returns {?string} - value\n */\nexport function extractOriginColor(\n  value: string,\n  opt: {\n    colorSpace?: string;\n    currentColor?: string;\n    dimension?: object;\n    format?: string;\n  } = {}\n): string | null {\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n    if (!value) {\n      return null;\n    }\n    if (!REG_START_REL.test(value)) {\n      return value;\n    }\n  } else {\n    return null;\n  }\n  const { currentColor, format } = opt;\n  const cacheKey = `{preProcess:${value},opt:${valueToJsonString(opt)}}`;\n  if (cachedResults.has(cacheKey)) {\n    return cachedResults.get(cacheKey) as string | null;\n  }\n  if (/currentcolor/.test(value)) {\n    if (currentColor) {\n      value = value.replace(/currentcolor/g, currentColor);\n    } else {\n      if (cacheKey) {\n        cachedResults.set(cacheKey, null!);\n      }\n      return null;\n    }\n  }\n  const cs = value.match(REG_REL_CAPT);\n  let colorSpace: string;\n  if (cs) {\n    [, colorSpace] = cs as [string, string];\n  } else {\n    return null;\n  }\n  opt.colorSpace = colorSpace;\n  if (REG_COLOR_CAPT.test(value)) {\n    const [, originColor] = value.match(REG_COLOR_CAPT) as [string, string];\n    const [, restValue] = value.split(originColor);\n    if (/^[a-z]+$/.test(originColor)) {\n      if (\n        !/^transparent$/.test(originColor) &&\n        !Object.prototype.hasOwnProperty.call(NAMED_COLORS, originColor)\n      ) {\n        if (cacheKey) {\n          cachedResults.set(cacheKey, null!);\n        }\n        return null;\n      }\n    } else if (format === VAL_SPEC) {\n      const resolvedOriginColor = resolve(originColor, opt) as string;\n      value = value.replace(originColor, resolvedOriginColor);\n    }\n    if (format === VAL_SPEC) {\n      const tokens = tokenize({ css: restValue as string });\n      const channelValues =\n        resolveColorChannels(tokens, opt) as Array<string> | null;\n      if (!Array.isArray(channelValues)) {\n        if (cacheKey) {\n          cachedResults.set(cacheKey, null!);\n        }\n        return null;\n      }\n      let channelValue;\n      if (channelValues.length === 3) {\n        channelValue = ` ${channelValues.join(' ')})`;\n      } else {\n        const [v1, v2, v3, v4] = channelValues as [\n          string,\n          string,\n          string,\n          string\n        ];\n        channelValue = ` ${v1} ${v2} ${v3} / ${v4})`;\n      }\n      value = value.replace(restValue!, channelValue);\n    }\n    // nested relative color\n  } else {\n    const [, restValue] = value.split(REG_START_REL) as [\n      string,\n      string\n    ];\n    if (REG_START_REL.test(restValue)) {\n      const tokens = tokenize({ css: restValue });\n      const originColor = [] as Array<string>;\n      let nest = 0;\n      while (tokens.length) {\n        const token = tokens.shift();\n        const [type, tokenValue] = token as [TokenType, string];\n        switch (type) {\n          case FUNC:\n          case PAREN_OPEN: {\n            originColor.push(tokenValue);\n            nest++;\n            break;\n          }\n          case PAREN_CLOSE: {\n            const lastValue = originColor[originColor.length - 1] as string;\n            if (lastValue === ' ') {\n              originColor.splice(-1, 1, tokenValue);\n            } else {\n              originColor.push(tokenValue);\n            }\n            nest--;\n            break;\n          }\n          case W_SPACE: {\n            const lastValue = originColor[originColor.length - 1] as string;\n            if (!lastValue.endsWith('(') && lastValue !== ' ') {\n              originColor.push(tokenValue);\n            }\n            break;\n          }\n          default: {\n            if (type !== COMMENT && type !== EOF) {\n              originColor.push(tokenValue);\n            }\n          }\n        }\n        if (nest === 0) {\n          break;\n        }\n      }\n      const resolvedOriginColor = resolveRelativeColor(\n        originColor.join('').trim(),\n        opt\n      ) as string | null;\n      if (!resolvedOriginColor) {\n        if (cacheKey) {\n          cachedResults.set(cacheKey, null!);\n        }\n        return null;\n      }\n      const channelValues =\n        resolveColorChannels(tokens, opt) as Array<string> | null;\n      if (!Array.isArray(channelValues)) {\n        if (cacheKey) {\n          cachedResults.set(cacheKey, null!);\n        }\n        return null;\n      }\n      let channelValue;\n      if (channelValues.length === 3) {\n        channelValue = ` ${channelValues.join(' ')})`;\n      } else {\n        const [v1, v2, v3, v4] = channelValues as [\n          string,\n          string,\n          string,\n          string\n        ];\n        channelValue = ` ${v1} ${v2} ${v3} / ${v4})`;\n      }\n      value = value.replace(restValue, `${resolvedOriginColor}${channelValue}`);\n    }\n  }\n  if (cacheKey) {\n    cachedResults.set(cacheKey, value);\n  }\n  return value;\n}\n\n/**\n * resolve relative color\n * @param {string} value - relative color value\n * @param {object} [opt] - options\n * @param {string} [opt.format] - output format\n * @returns {?string} - value\n */\nexport function resolveRelativeColor(\n  value: string,\n  opt: {\n    colorSpace?: string;\n    currentColor?: string;\n    dimension?: object;\n    format?: string;\n  } = {}\n): string | null {\n  const { format } = opt;\n  if (isString(value)) {\n    if (REG_FN_VAR.test(value)) {\n      if (format === VAL_SPEC) {\n        return value;\n        // var() must be resolved before resolveRelativeColor()\n      } else {\n        throw new SyntaxError(`Unexpected token ${FN_VAR} found.`);\n      }\n    } else if (!REG_REL.test(value)) {\n      return value;\n    }\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string`);\n  }\n  const cacheKey = `{relativeColor:${value},opt:${valueToJsonString(opt)}}`;\n  if (cachedResults.has(cacheKey)) {\n    return cachedResults.get(cacheKey) as string | null;\n  }\n  const originColor = extractOriginColor(value, opt);\n  if (originColor) {\n    value = originColor;\n  } else {\n    if (cacheKey) {\n      cachedResults.set(cacheKey, null!);\n    }\n    return null;\n  }\n  if (format === VAL_SPEC) {\n    if (value.startsWith('rgba(')) {\n      value = value.replace(/^rgba\\(/, 'rgb(');\n    } else if (value.startsWith('hsla(')) {\n      value = value.replace(/^hsla\\(/, 'hsl(');\n    }\n    return value;\n  }\n  const tokens = tokenize({ css: value });\n  const components = parseComponentValue(tokens);\n  const parsedComponents = colorParser(components as ComponentValue);\n  if (!parsedComponents) {\n    if (cacheKey) {\n      cachedResults.set(cacheKey, null!);\n    }\n    return null;\n  }\n  const {\n    alpha: alphaComponent,\n    channels: channelsComponent,\n    colorNotation,\n    syntaxFlags\n  } = parsedComponents;\n  let alpha: number | string;\n  if (Number.isNaN(Number(alphaComponent))) {\n    if ((syntaxFlags instanceof Set) && syntaxFlags.has(NONE_KEY)) {\n      alpha = NONE;\n    } else {\n      alpha = 0;\n    }\n  } else {\n    alpha = roundToPrecision(alphaComponent as number, OCT);\n  }\n  let v1: number | string;\n  let v2: number | string;\n  let v3: number | string;\n  [v1, v2, v3] = channelsComponent;\n  let resolvedValue;\n  if (REG_CS_CIE.test(colorNotation)) {\n    const hasNone = (syntaxFlags instanceof Set) && syntaxFlags.has(NONE_KEY);\n    if (Number.isNaN(v1)) {\n      if (hasNone) {\n        v1 = NONE;\n      } else {\n        v1 = 0;\n      }\n    } else {\n      v1 = roundToPrecision(v1, HEX);\n    }\n    if (Number.isNaN(v2)) {\n      if (hasNone) {\n        v2 = NONE;\n      } else {\n        v2 = 0;\n      }\n    } else {\n      v2 = roundToPrecision(v2, HEX);\n    }\n    if (Number.isNaN(v3)) {\n      if (hasNone) {\n        v3 = NONE;\n      } else {\n        v3 = 0;\n      }\n    } else {\n      v3 = roundToPrecision(v3, HEX);\n    }\n    if (alpha === 1) {\n      resolvedValue = `${colorNotation}(${v1} ${v2} ${v3})`;\n    } else {\n      resolvedValue = `${colorNotation}(${v1} ${v2} ${v3} / ${alpha})`;\n    }\n  } else if (REG_CS_HSL.test(colorNotation)) {\n    if (Number.isNaN(v1)) {\n      v1 = 0;\n    }\n    if (Number.isNaN(v2)) {\n      v2 = 0;\n    }\n    if (Number.isNaN(v3)) {\n      v3 = 0;\n    }\n    let [r, g, b] = colorToRgb(\n      `${colorNotation}(${v1} ${v2} ${v3} / ${alpha})`\n    ) as [number, number, number];\n    r = roundToPrecision(r / MAX_RGB, DEC);\n    g = roundToPrecision(g / MAX_RGB, DEC);\n    b = roundToPrecision(b / MAX_RGB, DEC);\n    if (alpha === 1) {\n      resolvedValue = `color(srgb ${r} ${g} ${b})`;\n    } else {\n      resolvedValue = `color(srgb ${r} ${g} ${b} / ${alpha})`;\n    }\n  } else {\n    const cs = colorNotation === 'rgb' ? 'srgb' : colorNotation;\n    const hasNone = (syntaxFlags instanceof Set) && syntaxFlags.has(NONE_KEY);\n    if (Number.isNaN(v1)) {\n      if (hasNone) {\n        v1 = NONE;\n      } else {\n        v1 = 0;\n      }\n    } else {\n      v1 = roundToPrecision(v1, DEC);\n    }\n    if (Number.isNaN(v2)) {\n      if (hasNone) {\n        v2 = NONE;\n      } else {\n        v2 = 0;\n      }\n    } else {\n      v2 = roundToPrecision(v2, DEC);\n    }\n    if (Number.isNaN(v3)) {\n      if (hasNone) {\n        v3 = NONE;\n      } else {\n        v3 = 0;\n      }\n    } else {\n      v3 = roundToPrecision(v3, DEC);\n    }\n    if (alpha === 1) {\n      resolvedValue = `color(${cs} ${v1} ${v2} ${v3})`;\n    } else {\n      resolvedValue = `color(${cs} ${v1} ${v2} ${v3} / ${alpha})`;\n    }\n  }\n  if (cacheKey) {\n    cachedResults.set(cacheKey, resolvedValue);\n  }\n  return resolvedValue;\n}\n"],"names":["TokenType","SyntaxFlag","FN_REL","SYN_COLOR_TYPE","SYN_MIX","CS_LAB","CS_LCH","SYN_FN_VAR","FN_REL_CAPT","SYN_FN_MATH","LRUCache","resolveDimension","isString","serializeCalc","valueToJsonString","NAMED_COLORS","VAL_SPEC","resolve","tokenize","FN_VAR","parseComponentValue","colorParser","NONE","roundToPrecision","colorToRgb"],"mappings":"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"}